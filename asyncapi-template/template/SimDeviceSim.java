// PLEASE DO NOT EDIT THIS FILE!!!
// IT IS AUTOMATICALLY GENERATED BY THE 'generateDeviceFiles' GRADLE TASK
// FROM THE TEMPLATE FILE 'asyncapi-template/template/SimDeviceSim.java'.
// EDIT THAT FILE INSTEAD.
package org.team199.wpiws.devices;

import java.math.BigDecimal;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

import org.team199.wpiws.Pair;
import org.team199.wpiws.ScopedObject;
import org.team199.wpiws.StateDevice;
import org.team199.wpiws.connection.ConnectionProcessor;
import org.team199.wpiws.connection.WSValue;
import org.team199.wpiws.interfaces.SimDeviceCallback;
import org.team199.wpiws.interfaces.StringCallback;

/**
 * Represents a miscellaneous simulated device
 */
public class SimDeviceSim extends StateDevice<SimDeviceSim.State> {

    private static final Map<String, SimDeviceSim.State> STATE_MAP = new ConcurrentHashMap<>();
    private static final Set<String> EXISTING_DEVICES = new ConcurrentSkipListSet<>();
    private static final Set<Pair<String, SimDeviceCallback>> DEVICE_CALLBACKS = new CopyOnWriteArraySet<>();

    /**
     * Creates a new SimDeviceSim
     * @param id the device identifier of this SimDeviceSim
     */
    public SimDeviceSim(String id) {
        super(id, STATE_MAP);
    }

    /**
     * Retrieves the specified value from this SimDeviceSim
     * @param name the name of the requested value
     * @return the requested value or <code>null</code>
     */
    public String get(String name) {
        return getState().values.get(name);
    }

    /**
     * Sets the specified value on the SimDeviceSim
     * @param name the name of the value
     * @param value the value to associate with the given name
     */
    public void set(String name, String value) {
        set(name, value, true);
    }

    /**
     * Sets the specified value on the SimDeviceSim
     * @param name the name of the value
     * @param value the value to associate with the given name
     */
    public void set(String name, boolean value) {
        getState().valueTypes.put(name, "b");
        set(name, String.valueOf(value), true);
    }

    /**
     * Sets the specified value on the SimDeviceSim
     * @param name the name of the value
     * @param value the value to associate with the given name
     */
    public void set(String name, double value) {
        getState().valueTypes.put(name, "d");
        getState().valueBidirectionality.putIfAbsent(name, false);
        set(name, String.valueOf(value), true);
    }

    /**
     * Sets the specified value to be bidirectional on the SimDeviceSim. This means that the value can be set from the robot code as well as from the simulation code.
     * This method MUST be called before the value is set from simulation code. If the value is first set by robot code, this is handled automatically.
     * For more information, see <a href="https://github.com/DeepBlueRobotics/WPIWebSockets/issues/30">DeepBlueRobotics/WPIWebSockets#30</a>.
     * @param name the name of the value
     */
    public void setBidirectional(String name) {
        if(Boolean.FALSE.equals(getState().valueBidirectionality.put(name, true))) { // This is the same as oldValue == false, but also accounts for null
            System.err.println("WARNING: SimDeviceSim (" + id + "): User code is setting " + name + " to be bidirectional, but it has already been used non-bidirectionally! This may cause unexpected behavior. (See DeepBlueRobotics/WPIWebSockets#30)");
        }
    }

    /**
     * Checks whether the specified value is bidirectional on the SimDeviceSim.
     * @param name the name of the value
     * @return <code>true</code> if the value is bidirectional, <code>false</code> if it is non-bidirectional or if the value does not yet exist
     */
    public boolean isBidirectional(String name) {
        return getState().valueBidirectionality.getOrDefault(name, false);
    }

    /**
     * Determines the prefix to use for the specified value when sending it to the robot code.
     * @param name the name of the value
     * @return the prefix to use for the specified value
     */
    public String getPrefix(String name) {
        return isBidirectional(name) ? "<>" : ">";
    }

    /**
     * Calls the specified callback with the device identifier of this device
     */
    public final Consumer<SimDeviceCallback> CALL_DEVICE_CALLBACK = callback -> callback.callback(id);
    /**
     * A Predicate describing whether this device's id starts with the given given String value of the pair (the SimDeviceCallback) argument is for internal use and does not affect the result
     */
    public final Predicate<Pair<String, SimDeviceCallback>> APPLIES_TO_ME = callbackPair -> id.startsWith(callbackPair.val1);
    /**
     * Retrieves the second argument of the given Pair
     */
    public static final Function<Pair<String, SimDeviceCallback>, SimDeviceCallback> FETCH_DEVICE_CALLBACK = pair -> pair.val2;
    /**
     * Retrieves the second argument of the given Pair
     */
    public static final Function<Pair<String, StringCallback>, StringCallback> FETCH_VALUE_CALLBACK = pair -> pair.val2;
    private void set(String name, String value, boolean notifyRobot) {
        if(EXISTING_DEVICES.add(id)) {
            DEVICE_CALLBACKS.stream().filter(APPLIES_TO_ME).map(FETCH_DEVICE_CALLBACK).forEach(CALL_DEVICE_CALLBACK);
        }
        getState().values.put(name, value);
        Consumer<StringCallback> callCallback = callback -> callback.callback(name, value);
        if(!getState().existingValues.contains(name)) {
            getState().existingValues.add(name);
            getState().valueCreatedCallbacks.forEach(callCallback);
        }
        if(get(value) == null || !value.equals(get(value))) {
            getState().valueChangedCallbacks.stream().filter(callbackPair -> callbackPair.val1.equals(name)).map(FETCH_VALUE_CALLBACK).forEach(callCallback);
        }
        if(notifyRobot) {
            Object valueObj;
            if(getState().valueTypes.containsKey(name)) {
                switch(getState().valueTypes.get(name)) {
                    case "b": {
                        valueObj = value.equals("true");
                        break;
                    }
                    case "d": {
                        valueObj = Double.parseDouble(value);
                        break;
                    }
                    default: {
                        valueObj = value;
                        break;
                    }
                }
            } else {
                valueObj = value;
            }
            ConnectionProcessor.broadcastMessage(id, "SimDevice", new WSValue(getPrefix(name) + name, valueObj));
        }
    }

    /**
     * Registers a SimValueCallback to be called whenever a specified value for this device is created
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with all currently initialized values
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelValueCreatedCallback(StringCallback)
     */
    public ScopedObject<StringCallback> registerValueCreatedCallback(StringCallback callback, boolean initialNotify) {
        getState().valueCreatedCallbacks.add(callback);
        if(initialNotify) {
            getState().existingValues.forEach(value -> callback.callback(value, get(value)));
        }
        return new ScopedObject<>(callback, CANCEL_VALUE_CREATED_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelValueCreatedCallback(StringCallback)}
     */
    public final Consumer<StringCallback> CANCEL_VALUE_CREATED_CALLBACK = this::cancelValueCreatedCallback;
    /**
     * Deregisters the given value created callback
     * @param callback the callback to deregister
     * @see #registerValueCreatedCallback(StringCallback, boolean)
     */
    public void cancelValueCreatedCallback(StringCallback callback) {
        getState().valueCreatedCallbacks.remove(callback);
    }

    /**
     * Registers a SimValueCallback to be called whenever the specified value of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with the current value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelValueChangedCallback(Pair)
     */
    public ScopedObject<Pair<String, StringCallback>> registerValueChangedCallback(String value, StringCallback callback, boolean initialNotify) {
        Pair<String, StringCallback> callbackPair = new Pair<>(value, callback);
        getState().valueChangedCallbacks.add(callbackPair);
        if(initialNotify) {
            callback.callback(value, get(value));
        }
        return new ScopedObject<>(callbackPair, CANCEL_VALUE_CHANGED_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelValueChangedCallback(Pair)}
     */
    public final Consumer<Pair<String, StringCallback>> CANCEL_VALUE_CHANGED_CALLBACK = this::cancelValueChangedCallback;
    /**
     * Deregisters the given value changed callback
     * @param callback the callback to deregister
     * @see #registerValueChangedCallback(String, StringCallback, boolean)
     */
    public void cancelValueChangedCallback(Pair<String, StringCallback> callback) {
        getState().valueChangedCallbacks.remove(callback);
    }

    /**
     * @return an array of the identifiers of all created SimDeviceSims. A SimDeviceSim is determined to be created if a value on it has been set.
     */
    public static String[] enumerateDevices(String prefix) {
        return EXISTING_DEVICES.stream().filter(name -> name.startsWith(prefix)).toArray(CREATE_STRING_ARRAY);
    }

    /**
     * @return an array of the value names of all values of this SimDeviceSim
     */
    public String[] enumerateValues(String prefix) {
        return getState().existingValues.stream().filter(name -> name.startsWith(prefix)).toArray(CREATE_STRING_ARRAY);
    }

    /**
     * Registers a SimDeviceCallback to be called whenever a new SimDeviceSim is created. A SimDeviceSim is determined to be created if a value on it has been set.
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with all created SimDeviceSims
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelDeviceCreatedCallback(Pair)
     */
    public static ScopedObject<Pair<String, SimDeviceCallback>> registerDeviceCreatedCallback(String prefix, SimDeviceCallback callback, boolean initialNotify) {
        Pair<String, SimDeviceCallback> callbackPair = new Pair<>(prefix, callback);
        DEVICE_CALLBACKS.add(callbackPair);
        if(initialNotify) {
            Arrays.stream(enumerateDevices(prefix)).forEach(callback::callback);
        }
        return new ScopedObject<>(callbackPair, CANCEL_DEVICE_CREATED_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelDeviceCreatedCallback(Pair)}
     */
    public static final Consumer<Pair<String, SimDeviceCallback>> CANCEL_DEVICE_CREATED_CALLBACK = SimDeviceSim::cancelDeviceCreatedCallback;
    /**
     * Deregisters the given device created callback
     * @param callback the callback to deregister
     * @see #registerDeviceCreatedCallback(String, SimDeviceCallback, boolean)
     */
    public static void cancelDeviceCreatedCallback(Pair<String, SimDeviceCallback> callback) {
        DEVICE_CALLBACKS.remove(callback);
    }

    /**
     * An implementation of {@link org.team199.wpiws.interfaces.DeviceMessageProcessor} which processes WPI HALSim messages for SimDeviceSims
     * @param device the device identifier of the device sending the message
     * @param data the data associated with the message
     */
    public static void processMessage(String device, String type, List<WSValue> data) {
        SimDeviceSim simDevice = new SimDeviceSim(device);
        data.stream().filter(Objects::nonNull).forEach(value -> {
            String key = value.getKey();
            String formattedKey;
            if(key.startsWith("<>")) {
                formattedKey = key.substring(2);
                if(Boolean.FALSE.equals(simDevice.getState().valueBidirectionality.put(formattedKey, true))) { // This is the same as oldValue == false, but also accounts for null
                    System.err.println("WARNING: SimDeviceSim (" + device + "): WPILib is setting " + formattedKey + " to be bidirectional, but it has already been used non-bidirectionally! This may cause unexpected behavior. (See DeepBlueRobotics/WPIWebSockets#30)");
                }
            } else {
                formattedKey = key.substring(1);
                if(Boolean.TRUE.equals(simDevice.getState().valueBidirectionality.put(formattedKey, false))) { // This is the same as oldValue == true, but also accounts for null
                    System.err.println("WARNING: SimDeviceSim (" + device + "): WPILib is setting " + formattedKey + " to be non-bidirectional, but it has already been used bidirectionally! This may cause unexpected behavior. (See DeepBlueRobotics/WPIWebSockets#30)");
                }
            }
            value.setKey(formattedKey);
            if(Boolean.class.isAssignableFrom(value.getValue().getClass())) {
                simDevice.getState().valueTypes.put(value.getKey(), "b");
            } else if(BigDecimal.class.isAssignableFrom(value.getValue().getClass())) {
                // NOTE: json-simple represents all numbers using BigDecimal.
                // Since there is no way to ensure that a numeric JSON numeric
                // value that is an integer in one message will continue to be an integer
                // in future messages, we interpret all numbers as doubles.
                simDevice.getState().valueTypes.put(value.getKey(), "d");
            } else {
                simDevice.getState().valueTypes.put(value.getKey(), "s");
            }
            simDevice.set(value.getKey(), value.getValue().toString(), false);
        });
    }

    @Override
    public State generateState() {
        return new State();
    }

    /**
     * Contains all information about the state of a SimDeviceSim
     */
    public static class State {
        public final Map<String, String> values = new ConcurrentHashMap<>();
        public final Map<String, String> valueTypes = new ConcurrentHashMap<>();
        public final Map<String, Boolean> valueBidirectionality = new ConcurrentHashMap<>();
        public final Set<String> existingValues = new ConcurrentSkipListSet<>();
        public final Set<StringCallback> valueCreatedCallbacks = new CopyOnWriteArraySet<>();
        public final Set<Pair<String, StringCallback>> valueChangedCallbacks = new CopyOnWriteArraySet<>();
    }

}
