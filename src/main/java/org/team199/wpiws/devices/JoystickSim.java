// PLEASE DO NOT EDIT THIS FILE!!!
// This file is auto-generated by https://github.com/DeepBlueRobotics/WPIWebSocketsTemplate
// To regenerate please run:
// 'ag -o "WebotsWebSocketsImpl/src/main/org/team199/wpiws/devices" "<path/to/wpilib-ws.yaml>" "https://github.com/DeepBlueRobotics/WPIWebSocketsTemplate.git"'
package org.team199.wpiws.devices;

import java.util.HashMap;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.team199.wpiws.ScopedObject;
import org.team199.wpiws.StateDevice;
import org.team199.wpiws.connection.ConnectionProcessor;
import org.team199.wpiws.connection.WSValue;
import org.team199.wpiws.interfaces.*;

/**
 * Represents a simulated joystick
 */
public class JoystickSim extends StateDevice<JoystickSim.State> {

    private static final HashMap<String, JoystickSim.State> STATE_MAP = new HashMap<>();

    /**
     * Creates a new JoystickSim
     * @param id the device identifier of this JoystickSim 
     */
    public JoystickSim(String id) {
        super(id, STATE_MAP);
    }
    
    @Override
    protected State generateState() {
        return new State();
    }
    
    /**
     * Registers a DoubleArrayCallback to be called whenever the axes of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current axes value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelAxesCallback(DoubleArrayCallback)
     */
    public ScopedObject<DoubleArrayCallback> registerAxesCallback(DoubleArrayCallback callback, boolean initialNotify) {
        getState().AXES_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().axes);
        }
        return new ScopedObject<>(callback, CANCEL_AXES_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelAxesCallback(DoubleArrayCallback)}
     */
    public final Consumer<DoubleArrayCallback> CANCEL_AXES_CALLBACK = this::cancelAxesCallback;
    /**
     * Deregisters the given axes callback
     * @param callback the callback to deregister
     * @see #registerAxesCallback(DoubleArrayCallback, boolean)
     */
    public void cancelAxesCallback(DoubleArrayCallback callback) {
        getState().AXES_CALLBACKS.remove(callback);
    }

    /**
     * @return 
     * @see #setAxes(double[])
     */
    public double[] getAxes() {
        return getState().axes;
    }

    /**
     * Set 
     * @see #getAxes()
     */
    public void setAxes(double[] axes) {
        setAxes(axes, true);
    }

    /**
     * A Consumer which calls the given callback with the current axes value of this PWMSim
     */
    public final Consumer<DoubleArrayCallback> CALL_AXES_CALLBACK = callback -> callback.callback(id, getState().axes);
    private void setAxes(double[] axes, boolean notifyRobot) {
        if(axes != getState().axes) {
            getState().axes = axes;
            getState().AXES_CALLBACKS.forEach(CALL_AXES_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "Joystick", new WSValue(">axes", axes));
        }
    }

    /**
     * Registers a IntegerArrayCallback to be called whenever the povs of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current povs value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelPovsCallback(IntegerArrayCallback)
     */
    public ScopedObject<IntegerArrayCallback> registerPovsCallback(IntegerArrayCallback callback, boolean initialNotify) {
        getState().POVS_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().povs);
        }
        return new ScopedObject<>(callback, CANCEL_POVS_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelPovsCallback(IntegerArrayCallback)}
     */
    public final Consumer<IntegerArrayCallback> CANCEL_POVS_CALLBACK = this::cancelPovsCallback;
    /**
     * Deregisters the given povs callback
     * @param callback the callback to deregister
     * @see #registerPovsCallback(IntegerArrayCallback, boolean)
     */
    public void cancelPovsCallback(IntegerArrayCallback callback) {
        getState().POVS_CALLBACKS.remove(callback);
    }

    /**
     * @return one array element per pov; value is a
     * @see #setPovs(int[])
     */
    public int[] getPovs() {
        return getState().povs;
    }

    /**
     * Set one array element per pov; value is a
     * @see #getPovs()
     */
    public void setPovs(int[] povs) {
        setPovs(povs, true);
    }

    /**
     * A Consumer which calls the given callback with the current povs value of this PWMSim
     */
    public final Consumer<IntegerArrayCallback> CALL_POVS_CALLBACK = callback -> callback.callback(id, getState().povs);
    private void setPovs(int[] povs, boolean notifyRobot) {
        if(povs != getState().povs) {
            getState().povs = povs;
            getState().POVS_CALLBACKS.forEach(CALL_POVS_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "Joystick", new WSValue(">povs", povs));
        }
    }

    /**
     * Registers a BooleanArrayCallback to be called whenever the buttons of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current buttons value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelButtonsCallback(BooleanArrayCallback)
     */
    public ScopedObject<BooleanArrayCallback> registerButtonsCallback(BooleanArrayCallback callback, boolean initialNotify) {
        getState().BUTTONS_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().buttons);
        }
        return new ScopedObject<>(callback, CANCEL_BUTTONS_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelButtonsCallback(BooleanArrayCallback)}
     */
    public final Consumer<BooleanArrayCallback> CANCEL_BUTTONS_CALLBACK = this::cancelButtonsCallback;
    /**
     * Deregisters the given buttons callback
     * @param callback the callback to deregister
     * @see #registerButtonsCallback(BooleanArrayCallback, boolean)
     */
    public void cancelButtonsCallback(BooleanArrayCallback callback) {
        getState().BUTTONS_CALLBACKS.remove(callback);
    }

    /**
     * @return state of all buttons on this joystick
     * @see #setButtons(boolean[])
     */
    public boolean[] getButtons() {
        return getState().buttons;
    }

    /**
     * Set state of all buttons on this joystick
     * @see #getButtons()
     */
    public void setButtons(boolean[] buttons) {
        setButtons(buttons, true);
    }

    /**
     * A Consumer which calls the given callback with the current buttons value of this PWMSim
     */
    public final Consumer<BooleanArrayCallback> CALL_BUTTONS_CALLBACK = callback -> callback.callback(id, getState().buttons);
    private void setButtons(boolean[] buttons, boolean notifyRobot) {
        if(buttons != getState().buttons) {
            getState().buttons = buttons;
            getState().BUTTONS_CALLBACKS.forEach(CALL_BUTTONS_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "Joystick", new WSValue(">buttons", buttons));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the rumbleleft of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current rumbleleft value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelRumbleLeftCallback(DoubleCallback)
     */
    public ScopedObject<DoubleCallback> registerRumbleLeftCallback(DoubleCallback callback, boolean initialNotify) {
        getState().RUMBLELEFT_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().rumbleleft);
        }
        return new ScopedObject<>(callback, CANCEL_RUMBLELEFT_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelRumbleLeftCallback(DoubleCallback)}
     */
    public final Consumer<DoubleCallback> CANCEL_RUMBLELEFT_CALLBACK = this::cancelRumbleLeftCallback;
    /**
     * Deregisters the given rumbleleft callback
     * @param callback the callback to deregister
     * @see #registerRumbleLeftCallback(DoubleCallback, boolean)
     */
    public void cancelRumbleLeftCallback(DoubleCallback callback) {
        getState().RUMBLELEFT_CALLBACKS.remove(callback);
    }

    /**
     * @return left rumble
     * @see #setRumbleLeft(double)
     */
    public double getRumbleLeft() {
        return getState().rumbleleft;
    }

    /**
     * Set left rumble
     * @see #getRumbleLeft()
     */
    public void setRumbleLeft(double rumbleleft) {
        setRumbleLeft(rumbleleft, true);
    }

    /**
     * A Consumer which calls the given callback with the current rumbleleft value of this PWMSim
     */
    public final Consumer<DoubleCallback> CALL_RUMBLELEFT_CALLBACK = callback -> callback.callback(id, getState().rumbleleft);
    private void setRumbleLeft(double rumbleleft, boolean notifyRobot) {
        if(rumbleleft != getState().rumbleleft) {
            getState().rumbleleft = rumbleleft;
            getState().RUMBLELEFT_CALLBACKS.forEach(CALL_RUMBLELEFT_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "Joystick", new WSValue("<rumble_left", rumbleleft));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the rumbleright of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current rumbleright value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelRumbleRightCallback(DoubleCallback)
     */
    public ScopedObject<DoubleCallback> registerRumbleRightCallback(DoubleCallback callback, boolean initialNotify) {
        getState().RUMBLERIGHT_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().rumbleright);
        }
        return new ScopedObject<>(callback, CANCEL_RUMBLERIGHT_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelRumbleRightCallback(DoubleCallback)}
     */
    public final Consumer<DoubleCallback> CANCEL_RUMBLERIGHT_CALLBACK = this::cancelRumbleRightCallback;
    /**
     * Deregisters the given rumbleright callback
     * @param callback the callback to deregister
     * @see #registerRumbleRightCallback(DoubleCallback, boolean)
     */
    public void cancelRumbleRightCallback(DoubleCallback callback) {
        getState().RUMBLERIGHT_CALLBACKS.remove(callback);
    }

    /**
     * @return right rumble
     * @see #setRumbleRight(double)
     */
    public double getRumbleRight() {
        return getState().rumbleright;
    }

    /**
     * Set right rumble
     * @see #getRumbleRight()
     */
    public void setRumbleRight(double rumbleright) {
        setRumbleRight(rumbleright, true);
    }

    /**
     * A Consumer which calls the given callback with the current rumbleright value of this PWMSim
     */
    public final Consumer<DoubleCallback> CALL_RUMBLERIGHT_CALLBACK = callback -> callback.callback(id, getState().rumbleright);
    private void setRumbleRight(double rumbleright, boolean notifyRobot) {
        if(rumbleright != getState().rumbleright) {
            getState().rumbleright = rumbleright;
            getState().RUMBLERIGHT_CALLBACKS.forEach(CALL_RUMBLERIGHT_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "Joystick", new WSValue("<rumble_right", rumbleright));
        }
    }

    /**
     * An implementation of {@link org.team199.wpiws.interfaces.DeviceMessageProcessor} which processes WPI HALSim messages for JoystickSims
     * @param device the device identifier of the device sending the message
     * @param data the data associated with the message
     */
    public static void processMessage(String device, List<WSValue> data) {
        // Process all of the values, but save the "<init" value for last
        // so that the rest of the state has been set when the initialize
        // callback is called.
        WSValue init = null;
        JoystickSim simDevice = new JoystickSim(device);

        for(WSValue value: data) {
            if (value.getKey().equals("<init"))
                init = value;
            else
                simDevice.processValue(value);
        }
        if (init != null)
            simDevice.processValue(init);
    }

    private final BiConsumer<double[], Boolean> SET_AXES = this::setAxes;
    private final BiConsumer<int[], Boolean> SET_POVS = this::setPovs;
    private final BiConsumer<boolean[], Boolean> SET_BUTTONS = this::setButtons;
    private final BiConsumer<Double, Boolean> SET_RUMBLELEFT = this::setRumbleLeft;
    private final BiConsumer<Double, Boolean> SET_RUMBLERIGHT = this::setRumbleRight;
    private void processValue(WSValue value) {
        if(value.getKey() instanceof String && value.getValue() != null) {
            switch((String)value.getKey()) {
                
                case ">axes": {
                    filterMessageAndIgnoreRobotState(value.getValue(), double[].class, SET_AXES);
                    break;
                }
                case ">povs": {
                    filterMessageAndIgnoreRobotState(value.getValue(), int[].class, SET_POVS);
                    break;
                }
                case ">buttons": {
                    filterMessageAndIgnoreRobotState(value.getValue(), boolean[].class, SET_BUTTONS);
                    break;
                }
                case "<rumble_left": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_RUMBLELEFT);
                    break;
                }
                case "<rumble_right": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_RUMBLERIGHT);
                    break;
                }
                default: {
                    System.err.println("JoystickSim ignored unrecognized WSValue: " + value.getKey() + ":" + value.getValue());
                }
            }
        }
    }

    /**
     * Contains all information about the state of a JoystickSim
     */
    public static class State {
        public double[] axes = new double[0];
        public int[] povs = new int[0];
        public boolean[] buttons = new boolean[0];
        public double rumbleleft = 0;
        public double rumbleright = 0;
        public final CopyOnWriteArrayList<DoubleArrayCallback> AXES_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<IntegerArrayCallback> POVS_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<BooleanArrayCallback> BUTTONS_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> RUMBLELEFT_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> RUMBLERIGHT_CALLBACKS = new CopyOnWriteArrayList<>();
    }

}
