// PLEASE DO NOT EDIT THIS FILE!!!
// This file is auto-generated by https://github.com/DeepBlueRobotics/WPIWebSocketsTemplate
// To regenerate please run:
// 'ag -o "WebotsWebSocketsImpl/src/main/org/team199/wpiws/devices" "<path/to/wpilib-ws.yaml>" "https://github.com/DeepBlueRobotics/WPIWebSocketsTemplate.git"'
package org.team199.wpiws.devices;

import java.util.HashMap;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.team199.wpiws.ScopedObject;
import org.team199.wpiws.StateDevice;
import org.team199.wpiws.connection.ConnectionProcessor;
import org.team199.wpiws.connection.WSValue;
import org.team199.wpiws.interfaces.*;

public class AccelerometerSim extends StateDevice<AccelerometerSim.State> {

    private static final CopyOnWriteArrayList<String> INITIALIZED_DEVICES = new CopyOnWriteArrayList<>();
    private static final CopyOnWriteArrayList<BooleanCallback> STATIC_INITIALIZED_CALLBACKS = new CopyOnWriteArrayList<>();
    
    private static final HashMap<String, AccelerometerSim.State> STATE_MAP = new HashMap<>();

    public AccelerometerSim(String id) {
        super(id, STATE_MAP);
    }
    
    public static ScopedObject<BooleanCallback> registerStaticInitializedCallback(BooleanCallback callback, boolean initialNotify) {
        STATIC_INITIALIZED_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            INITIALIZED_DEVICES.forEach(device -> callback.callback(device, true));
        }
        return new ScopedObject<>(callback, CANCEL_STATIC_INITIALIZED_CALLBACK);
    }

    public static final Consumer<BooleanCallback> CANCEL_STATIC_INITIALIZED_CALLBACK = AccelerometerSim::cancelStaticInitializedCallback;
    public static void cancelStaticInitializedCallback(BooleanCallback callback) {
        STATIC_INITIALIZED_CALLBACKS.remove(callback);
    }
    
    public ScopedObject<BooleanCallback> registerInitializedCallback(BooleanCallback callback, boolean initialNotify) {
        getState().INITIALIZED_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().init);
        }
        return new ScopedObject<>(callback, CANCEL_INITIALIZED_CALLBACK);
    }

    public final Consumer<BooleanCallback> CANCEL_INITIALIZED_CALLBACK = this::cancelInitializedCallback;
    public void cancelInitializedCallback(BooleanCallback callback) {
        getState().INITIALIZED_CALLBACKS.remove(callback);
    }

    public boolean getInitialized() {
        return getState().init;
    }

    public void setInitialized(boolean initialized) {
        setInitialized(initialized, true);
    }

    public final Consumer<BooleanCallback> CALL_INITIALIZED_CALLBACK = callback -> callback.callback(id, getState().init);
    private void setInitialized(boolean initialized, boolean notifyRobot) {
        getState().init = initialized;
        if(initialized) {
            STATIC_INITIALIZED_CALLBACKS.forEach(CALL_INITIALIZED_CALLBACK);
            getState().INITIALIZED_CALLBACKS.forEach(CALL_INITIALIZED_CALLBACK);
            INITIALIZED_DEVICES.addIfAbsent(id);
        } else {
            INITIALIZED_DEVICES.remove(id);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "Accel", new WSValue("<init", initialized));
        }
    }

    public static String[] enumerateDevices() {
        return INITIALIZED_DEVICES.toArray(CREATE_STRING_ARRAY);
    }
    
    @Override
    protected State generateState() {
        return new State();
    }
    
    public ScopedObject<DoubleCallback> registerRangeCallback(DoubleCallback callback, boolean initialNotify) {
        getState().RANGE_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().range);
        }
        return new ScopedObject<>(callback, CANCEL_RANGE_CALLBACK);
    }

    public final Consumer<DoubleCallback> CANCEL_RANGE_CALLBACK = this::cancelRangeCallback;
    public void cancelRangeCallback(DoubleCallback callback) {
        getState().RANGE_CALLBACKS.remove(callback);
    }

    public double getRange() {
        return getState().range;
    }

    public void setRange(double range) {
        setRange(range, true);
    }

    public final Consumer<DoubleCallback> CALL_RANGE_CALLBACK = callback -> callback.callback(id, getState().range);
    private void setRange(double range, boolean notifyRobot) {
        if(range != getState().range) {
            getState().range = range;
            getState().RANGE_CALLBACKS.forEach(CALL_RANGE_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "Accel", new WSValue("<range", range));
        }
    }

    public ScopedObject<DoubleCallback> registerXCallback(DoubleCallback callback, boolean initialNotify) {
        getState().X_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().x);
        }
        return new ScopedObject<>(callback, CANCEL_X_CALLBACK);
    }

    public final Consumer<DoubleCallback> CANCEL_X_CALLBACK = this::cancelXCallback;
    public void cancelXCallback(DoubleCallback callback) {
        getState().X_CALLBACKS.remove(callback);
    }

    public double getX() {
        return getState().x;
    }

    public void setX(double x) {
        setX(x, true);
    }

    public final Consumer<DoubleCallback> CALL_X_CALLBACK = callback -> callback.callback(id, getState().x);
    private void setX(double x, boolean notifyRobot) {
        if(x != getState().x) {
            getState().x = x;
            getState().X_CALLBACKS.forEach(CALL_X_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "Accel", new WSValue(">x", x));
        }
    }

    public ScopedObject<DoubleCallback> registerYCallback(DoubleCallback callback, boolean initialNotify) {
        getState().Y_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().y);
        }
        return new ScopedObject<>(callback, CANCEL_Y_CALLBACK);
    }

    public final Consumer<DoubleCallback> CANCEL_Y_CALLBACK = this::cancelYCallback;
    public void cancelYCallback(DoubleCallback callback) {
        getState().Y_CALLBACKS.remove(callback);
    }

    public double getY() {
        return getState().y;
    }

    public void setY(double y) {
        setY(y, true);
    }

    public final Consumer<DoubleCallback> CALL_Y_CALLBACK = callback -> callback.callback(id, getState().y);
    private void setY(double y, boolean notifyRobot) {
        if(y != getState().y) {
            getState().y = y;
            getState().Y_CALLBACKS.forEach(CALL_Y_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "Accel", new WSValue(">y", y));
        }
    }

    public ScopedObject<DoubleCallback> registerZCallback(DoubleCallback callback, boolean initialNotify) {
        getState().Z_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().z);
        }
        return new ScopedObject<>(callback, CANCEL_Z_CALLBACK);
    }

    public final Consumer<DoubleCallback> CANCEL_Z_CALLBACK = this::cancelZCallback;
    public void cancelZCallback(DoubleCallback callback) {
        getState().Z_CALLBACKS.remove(callback);
    }

    public double getZ() {
        return getState().z;
    }

    public void setZ(double z) {
        setZ(z, true);
    }

    public final Consumer<DoubleCallback> CALL_Z_CALLBACK = callback -> callback.callback(id, getState().z);
    private void setZ(double z, boolean notifyRobot) {
        if(z != getState().z) {
            getState().z = z;
            getState().Z_CALLBACKS.forEach(CALL_Z_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "Accel", new WSValue(">z", z));
        }
    }

    public static void processMessage(String device, List<WSValue> data) {
        AccelerometerSim simDevice = new AccelerometerSim(device);
        for(WSValue value: data) {
            simDevice.processValue(value);
        }
    }

    private final BiConsumer<Boolean, Boolean> SET_INITIALIZED = this::setInitialized;
    private final BiConsumer<Double, Boolean> SET_RANGE = this::setRange;
    private final BiConsumer<Double, Boolean> SET_X = this::setX;
    private final BiConsumer<Double, Boolean> SET_Y = this::setY;
    private final BiConsumer<Double, Boolean> SET_Z = this::setZ;
    private void processValue(WSValue value) {
        if(value.getKey() instanceof String && value.getValue() != null) {
            switch((String)value.getKey()) {
                case "<init": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Boolean.class, SET_INITIALIZED);
                    break;
                }
                case "<range": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_RANGE);
                    break;
                }
                case ">x": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_X);
                    break;
                }
                case ">y": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_Y);
                    break;
                }
                case ">z": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_Z);
                    break;
                }
            }
        }
    }

    public static class State {
        public boolean init = false;
        public double range = 0;
        public double x = 0;
        public double y = 0;
        public double z = 0;
        public final CopyOnWriteArrayList<BooleanCallback> INITIALIZED_CALLBACKS = new CopyOnWriteArrayList<>();
        public final CopyOnWriteArrayList<DoubleCallback> RANGE_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> X_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> Y_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> Z_CALLBACKS = new CopyOnWriteArrayList<>();
    }

}