// PLEASE DO NOT EDIT THIS FILE!!!
// This file is auto-generated.
// To regenerate all of these *Sim.java files, run the following from the WPIWebSockets folder:
// npx -p @asyncapi/generator ag --force-write -o ./src/main/java/org/team199/wpiws/devices asyncapi-template/wpilib-ws.yaml asyncapi-template/
package org.team199.wpiws.devices;

import java.util.HashMap;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.team199.wpiws.ScopedObject;
import org.team199.wpiws.StateDevice;
import org.team199.wpiws.connection.ConnectionProcessor;
import org.team199.wpiws.connection.WSValue;
import org.team199.wpiws.interfaces.*;

/**
 * Represents a simulated dpwm
 */
public class dPWMSim extends StateDevice<dPWMSim.State> {

    private static final CopyOnWriteArrayList<String> INITIALIZED_DEVICES = new CopyOnWriteArrayList<>();
    private static final CopyOnWriteArrayList<BooleanCallback> STATIC_INITIALIZED_CALLBACKS = new CopyOnWriteArrayList<>();
    
    private static final HashMap<String, dPWMSim.State> STATE_MAP = new HashMap<>();

    /**
     * Creates a new dPWMSim
     * @param id the device identifier of this dPWMSim 
     */
    public dPWMSim(String id) {
        super(id, STATE_MAP);
    }
    
    /**
     * Registers a BooleanCallback to be called whenever false dPWMSim device is initialized or uninitialized
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with the device identifiers of all currently initialized dPWMSims
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelStaticInitializedCallback(BooleanCallback)
     * @see #registerInitializedCallback(BooleanCallback, boolean)
     */
    public static ScopedObject<BooleanCallback> registerStaticInitializedCallback(BooleanCallback callback, boolean initialNotify) {
        STATIC_INITIALIZED_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            INITIALIZED_DEVICES.forEach(device -> callback.callback(device, true));
        }
        return new ScopedObject<>(callback, CANCEL_STATIC_INITIALIZED_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelStaticInitializedCallback(BooleanCallback)}
     */
    public static final Consumer<BooleanCallback> CANCEL_STATIC_INITIALIZED_CALLBACK = dPWMSim::cancelStaticInitializedCallback;
    /**
     * Deregisters the given static initialized callback
     * @param callback the callback to deregister
     * @see #registerStaticInitializedCallback(BooleanCallback, boolean)
     */
    public static void cancelStaticInitializedCallback(BooleanCallback callback) {
        STATIC_INITIALIZED_CALLBACKS.remove(callback);
    }
    
    /**
     * Registers a BooleanCallback to be called whenever this device is initialized or uninitialized
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current initialized state
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelInitializedCallback(BooleanCallback)
     * @see #registerStaticInitializedCallback(BooleanCallback, boolean)
     */
    public ScopedObject<BooleanCallback> registerInitializedCallback(BooleanCallback callback, boolean initialNotify) {
        getState().INITIALIZED_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().init);
        }
        return new ScopedObject<>(callback, CANCEL_INITIALIZED_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelInitializedCallback(BooleanCallback)}
     */
    public final Consumer<BooleanCallback> CANCEL_INITIALIZED_CALLBACK = this::cancelInitializedCallback;
    /**
     * Deregisters the given initialized callback
     * @param callback the callback to deregister
     * @see #registerInitializedCallback(BooleanCallback, boolean)
     */
    public void cancelInitializedCallback(BooleanCallback callback) {
        getState().INITIALIZED_CALLBACKS.remove(callback);
    }

    /**
     * @return whether this dPWMSim is initialized
     */
    public boolean getInitialized() {
        return getState().init;
    }

    /**
     * Sets the initialized state of this dPWMSim
     * @param initialized the new initialized state of this dPWMSim
     */
    public void setInitialized(boolean initialized) {
        setInitialized(initialized, true);
    }

    /**
     * A Consumer which calls the given BooleanCallback with the current initialized state of this dPWMSim
     */
    public final Consumer<BooleanCallback> CALL_INITIALIZED_CALLBACK = callback -> callback.callback(id, getState().init);
    private void setInitialized(boolean initialized, boolean notifyRobot) {
        getState().init = initialized;
        if(initialized) {
            STATIC_INITIALIZED_CALLBACKS.forEach(CALL_INITIALIZED_CALLBACK);
            getState().INITIALIZED_CALLBACKS.forEach(CALL_INITIALIZED_CALLBACK);
            INITIALIZED_DEVICES.addIfAbsent(id);
        } else {
            INITIALIZED_DEVICES.remove(id);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "dPWM", new WSValue("<init", initialized));
        }
    }

    /**
     * @return an array of the identifiers of all currently initialized dPWMSims
     */
    public static String[] enumerateDevices() {
        return INITIALIZED_DEVICES.toArray(CREATE_STRING_ARRAY);
    }
    
    @Override
    protected State generateState() {
        return new State();
    }
    
    /**
     * Registers a DoubleCallback to be called whenever the dutycycle of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current dutycycle value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelDutyCycleCallback(DoubleCallback)
     */
    public ScopedObject<DoubleCallback> registerDutyCycleCallback(DoubleCallback callback, boolean initialNotify) {
        getState().DUTYCYCLE_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().dutycycle);
        }
        return new ScopedObject<>(callback, CANCEL_DUTYCYCLE_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelDutyCycleCallback(DoubleCallback)}
     */
    public final Consumer<DoubleCallback> CANCEL_DUTYCYCLE_CALLBACK = this::cancelDutyCycleCallback;
    /**
     * Deregisters the given dutycycle callback
     * @param callback the callback to deregister
     * @see #registerDutyCycleCallback(DoubleCallback, boolean)
     */
    public void cancelDutyCycleCallback(DoubleCallback callback) {
        getState().DUTYCYCLE_CALLBACKS.remove(callback);
    }

    /**
     * @return duty cycle %
     * @see #setDutyCycle(double)
     */
    public double getDutyCycle() {
        return getState().dutycycle;
    }

    /**
     * Set duty cycle %
     * @see #getDutyCycle()
     */
    public void setDutyCycle(double dutycycle) {
        setDutyCycle(dutycycle, true);
    }

    /**
     * A Consumer which calls the given callback with the current dutycycle value of this PWMSim
     */
    public final Consumer<DoubleCallback> CALL_DUTYCYCLE_CALLBACK = callback -> callback.callback(id, getState().dutycycle);
    private void setDutyCycle(double dutycycle, boolean notifyRobot) {
        if(dutycycle != getState().dutycycle) {
            getState().dutycycle = dutycycle;
            getState().DUTYCYCLE_CALLBACKS.forEach(CALL_DUTYCYCLE_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "dPWM", new WSValue("<duty_cycle", dutycycle));
        }
    }

    /**
     * Registers a IntegerCallback to be called whenever the diopin of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current diopin value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelDioPinCallback(IntegerCallback)
     */
    public ScopedObject<IntegerCallback> registerDioPinCallback(IntegerCallback callback, boolean initialNotify) {
        getState().DIOPIN_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().diopin);
        }
        return new ScopedObject<>(callback, CANCEL_DIOPIN_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelDioPinCallback(IntegerCallback)}
     */
    public final Consumer<IntegerCallback> CANCEL_DIOPIN_CALLBACK = this::cancelDioPinCallback;
    /**
     * Deregisters the given diopin callback
     * @param callback the callback to deregister
     * @see #registerDioPinCallback(IntegerCallback, boolean)
     */
    public void cancelDioPinCallback(IntegerCallback callback) {
        getState().DIOPIN_CALLBACKS.remove(callback);
    }

    /**
     * @return dio pin number
     * @see #setDioPin(int)
     */
    public int getDioPin() {
        return getState().diopin;
    }

    /**
     * Set dio pin number
     * @see #getDioPin()
     */
    public void setDioPin(int diopin) {
        setDioPin(diopin, true);
    }

    /**
     * A Consumer which calls the given callback with the current diopin value of this PWMSim
     */
    public final Consumer<IntegerCallback> CALL_DIOPIN_CALLBACK = callback -> callback.callback(id, getState().diopin);
    private void setDioPin(int diopin, boolean notifyRobot) {
        if(diopin != getState().diopin) {
            getState().diopin = diopin;
            getState().DIOPIN_CALLBACKS.forEach(CALL_DIOPIN_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "dPWM", new WSValue("<dio_pin", diopin));
        }
    }

    /**
     * An implementation of {@link org.team199.wpiws.interfaces.DeviceMessageProcessor} which processes WPI HALSim messages for dPWMSims
     * @param device the device identifier of the device sending the message
     * @param data the data associated with the message
     */
    public static void processMessage(String device, List<WSValue> data) {
        // Process all of the values, but save the "<init" value for last
        // so that the rest of the state has been set when the initialize
        // callback is called.
        WSValue init = null;
        dPWMSim simDevice = new dPWMSim(device);

        for(WSValue value: data) {
            if (value.getKey().equals("<init"))
                init = value;
            else
                simDevice.processValue(value);
        }
        if (init != null)
            simDevice.processValue(init);
    }

    private final BiConsumer<Boolean, Boolean> SET_INITIALIZED = this::setInitialized;
    private final BiConsumer<Double, Boolean> SET_DUTYCYCLE = this::setDutyCycle;
    private final BiConsumer<Integer, Boolean> SET_DIOPIN = this::setDioPin;
    private void processValue(WSValue value) {
        if(value.getKey() instanceof String && value.getValue() != null) {
            switch((String)value.getKey()) {
                case "<init": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Boolean.class, SET_INITIALIZED);
                    break;
                }
                case "<duty_cycle": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_DUTYCYCLE);
                    break;
                }
                case "<dio_pin": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Integer.class, SET_DIOPIN);
                    break;
                }
                default: {
                    System.err.println("dPWMSim ignored unrecognized WSValue: " + value.getKey() + ":" + value.getValue());
                }
            }
        }
    }

    /**
     * Contains all information about the state of a dPWMSim
     */
    public static class State {
        public boolean init = false;
        public double dutycycle = 0;
        public int diopin = 0;
        public final CopyOnWriteArrayList<BooleanCallback> INITIALIZED_CALLBACKS = new CopyOnWriteArrayList<>();
        public final CopyOnWriteArrayList<DoubleCallback> DUTYCYCLE_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<IntegerCallback> DIOPIN_CALLBACKS = new CopyOnWriteArrayList<>();
    }

}
