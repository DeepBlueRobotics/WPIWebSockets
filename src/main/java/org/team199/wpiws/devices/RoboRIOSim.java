// PLEASE DO NOT EDIT THIS FILE!!!
// This file is auto-generated.
// To regenerate all of these *Sim.java files, run the following from the WPIWebSockets folder:
// npx -p @asyncapi/generator ag --force-write -o ./src/main/java/org/team199/wpiws/devices asyncapi-template/wpilib-ws.yaml asyncapi-template/
package org.team199.wpiws.devices;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.team199.wpiws.ScopedObject;
import org.team199.wpiws.StateDevice;
import org.team199.wpiws.connection.ConnectionProcessor;
import org.team199.wpiws.connection.WSValue;
import org.team199.wpiws.interfaces.*;

/**
 * Represents a simulated roborio
 */
public class RoboRIOSim {

    private static final RoboRIOSim.State STATE = new State();
    
    protected static RoboRIOSim.State getState() {
        return STATE;
    }
    
    /**
     * Registers a BooleanCallback to be called whenever the fpgabutton of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current fpgabutton value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelFpgaButtonCallback(BooleanCallback)
     */
    public static ScopedObject<BooleanCallback> registerFpgaButtonCallback(BooleanCallback callback, boolean initialNotify) {
        getState().FPGABUTTON_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().fpgabutton);
        }
        return new ScopedObject<>(callback, CANCEL_FPGABUTTON_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelFpgaButtonCallback(BooleanCallback)}
     */
    public static final Consumer<BooleanCallback> CANCEL_FPGABUTTON_CALLBACK = RoboRIOSim::cancelFpgaButtonCallback;
    /**
     * Deregisters the given fpgabutton callback
     * @param callback the callback to deregister
     * @see #registerFpgaButtonCallback(BooleanCallback, boolean)
     */
    public static void cancelFpgaButtonCallback(BooleanCallback callback) {
        getState().FPGABUTTON_CALLBACKS.remove(callback);
    }

    /**
     * @return fpga button state
     * @see #setFpgaButton(boolean)
     */
    public static boolean getFpgaButton() {
        return getState().fpgabutton;
    }

    /**
     * Set fpga button state
     * @see #getFpgaButton()
     */
    public static void setFpgaButton(boolean fpgabutton) {
        setFpgaButton(fpgabutton, true);
    }

    /**
     * A Consumer which calls the given callback with the current fpgabutton value of this PWMSim
     */
    public static final Consumer<BooleanCallback> CALL_FPGABUTTON_CALLBACK = callback -> callback.callback("", getState().fpgabutton);
    private static void setFpgaButton(boolean fpgabutton, boolean notifyRobot) {
        if(fpgabutton != getState().fpgabutton) {
            getState().fpgabutton = fpgabutton;
            getState().FPGABUTTON_CALLBACKS.forEach(CALL_FPGABUTTON_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">fpga_button", fpgabutton));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the vinvoltage of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current vinvoltage value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelVinVoltageCallback(DoubleCallback)
     */
    public static ScopedObject<DoubleCallback> registerVinVoltageCallback(DoubleCallback callback, boolean initialNotify) {
        getState().VINVOLTAGE_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().vinvoltage);
        }
        return new ScopedObject<>(callback, CANCEL_VINVOLTAGE_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelVinVoltageCallback(DoubleCallback)}
     */
    public static final Consumer<DoubleCallback> CANCEL_VINVOLTAGE_CALLBACK = RoboRIOSim::cancelVinVoltageCallback;
    /**
     * Deregisters the given vinvoltage callback
     * @param callback the callback to deregister
     * @see #registerVinVoltageCallback(DoubleCallback, boolean)
     */
    public static void cancelVinVoltageCallback(DoubleCallback callback) {
        getState().VINVOLTAGE_CALLBACKS.remove(callback);
    }

    /**
     * @return vin rail voltage
     * @see #setVinVoltage(double)
     */
    public static double getVinVoltage() {
        return getState().vinvoltage;
    }

    /**
     * Set vin rail voltage
     * @see #getVinVoltage()
     */
    public static void setVinVoltage(double vinvoltage) {
        setVinVoltage(vinvoltage, true);
    }

    /**
     * A Consumer which calls the given callback with the current vinvoltage value of this PWMSim
     */
    public static final Consumer<DoubleCallback> CALL_VINVOLTAGE_CALLBACK = callback -> callback.callback("", getState().vinvoltage);
    private static void setVinVoltage(double vinvoltage, boolean notifyRobot) {
        if(vinvoltage != getState().vinvoltage) {
            getState().vinvoltage = vinvoltage;
            getState().VINVOLTAGE_CALLBACKS.forEach(CALL_VINVOLTAGE_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">vin_voltage", vinvoltage));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the vincurrent of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current vincurrent value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelVinCurrentCallback(DoubleCallback)
     */
    public static ScopedObject<DoubleCallback> registerVinCurrentCallback(DoubleCallback callback, boolean initialNotify) {
        getState().VINCURRENT_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().vincurrent);
        }
        return new ScopedObject<>(callback, CANCEL_VINCURRENT_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelVinCurrentCallback(DoubleCallback)}
     */
    public static final Consumer<DoubleCallback> CANCEL_VINCURRENT_CALLBACK = RoboRIOSim::cancelVinCurrentCallback;
    /**
     * Deregisters the given vincurrent callback
     * @param callback the callback to deregister
     * @see #registerVinCurrentCallback(DoubleCallback, boolean)
     */
    public static void cancelVinCurrentCallback(DoubleCallback callback) {
        getState().VINCURRENT_CALLBACKS.remove(callback);
    }

    /**
     * @return vin rail current
     * @see #setVinCurrent(double)
     */
    public static double getVinCurrent() {
        return getState().vincurrent;
    }

    /**
     * Set vin rail current
     * @see #getVinCurrent()
     */
    public static void setVinCurrent(double vincurrent) {
        setVinCurrent(vincurrent, true);
    }

    /**
     * A Consumer which calls the given callback with the current vincurrent value of this PWMSim
     */
    public static final Consumer<DoubleCallback> CALL_VINCURRENT_CALLBACK = callback -> callback.callback("", getState().vincurrent);
    private static void setVinCurrent(double vincurrent, boolean notifyRobot) {
        if(vincurrent != getState().vincurrent) {
            getState().vincurrent = vincurrent;
            getState().VINCURRENT_CALLBACKS.forEach(CALL_VINCURRENT_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">vin_current", vincurrent));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the voltage6v of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current voltage6v value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelVoltage6vCallback(DoubleCallback)
     */
    public static ScopedObject<DoubleCallback> registerVoltage6vCallback(DoubleCallback callback, boolean initialNotify) {
        getState().VOLTAGE6V_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().voltage6v);
        }
        return new ScopedObject<>(callback, CANCEL_VOLTAGE6V_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelVoltage6vCallback(DoubleCallback)}
     */
    public static final Consumer<DoubleCallback> CANCEL_VOLTAGE6V_CALLBACK = RoboRIOSim::cancelVoltage6vCallback;
    /**
     * Deregisters the given voltage6v callback
     * @param callback the callback to deregister
     * @see #registerVoltage6vCallback(DoubleCallback, boolean)
     */
    public static void cancelVoltage6vCallback(DoubleCallback callback) {
        getState().VOLTAGE6V_CALLBACKS.remove(callback);
    }

    /**
     * @return 6v rail voltage
     * @see #setVoltage6v(double)
     */
    public static double getVoltage6v() {
        return getState().voltage6v;
    }

    /**
     * Set 6v rail voltage
     * @see #getVoltage6v()
     */
    public static void setVoltage6v(double voltage6v) {
        setVoltage6v(voltage6v, true);
    }

    /**
     * A Consumer which calls the given callback with the current voltage6v value of this PWMSim
     */
    public static final Consumer<DoubleCallback> CALL_VOLTAGE6V_CALLBACK = callback -> callback.callback("", getState().voltage6v);
    private static void setVoltage6v(double voltage6v, boolean notifyRobot) {
        if(voltage6v != getState().voltage6v) {
            getState().voltage6v = voltage6v;
            getState().VOLTAGE6V_CALLBACKS.forEach(CALL_VOLTAGE6V_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">6v_voltage", voltage6v));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the current6v of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current current6v value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelCurrent6vCallback(DoubleCallback)
     */
    public static ScopedObject<DoubleCallback> registerCurrent6vCallback(DoubleCallback callback, boolean initialNotify) {
        getState().CURRENT6V_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().current6v);
        }
        return new ScopedObject<>(callback, CANCEL_CURRENT6V_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelCurrent6vCallback(DoubleCallback)}
     */
    public static final Consumer<DoubleCallback> CANCEL_CURRENT6V_CALLBACK = RoboRIOSim::cancelCurrent6vCallback;
    /**
     * Deregisters the given current6v callback
     * @param callback the callback to deregister
     * @see #registerCurrent6vCallback(DoubleCallback, boolean)
     */
    public static void cancelCurrent6vCallback(DoubleCallback callback) {
        getState().CURRENT6V_CALLBACKS.remove(callback);
    }

    /**
     * @return 6v rail current
     * @see #setCurrent6v(double)
     */
    public static double getCurrent6v() {
        return getState().current6v;
    }

    /**
     * Set 6v rail current
     * @see #getCurrent6v()
     */
    public static void setCurrent6v(double current6v) {
        setCurrent6v(current6v, true);
    }

    /**
     * A Consumer which calls the given callback with the current current6v value of this PWMSim
     */
    public static final Consumer<DoubleCallback> CALL_CURRENT6V_CALLBACK = callback -> callback.callback("", getState().current6v);
    private static void setCurrent6v(double current6v, boolean notifyRobot) {
        if(current6v != getState().current6v) {
            getState().current6v = current6v;
            getState().CURRENT6V_CALLBACKS.forEach(CALL_CURRENT6V_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">6v_current", current6v));
        }
    }

    /**
     * Registers a BooleanCallback to be called whenever the active6v of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current active6v value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelActive6vCallback(BooleanCallback)
     */
    public static ScopedObject<BooleanCallback> registerActive6vCallback(BooleanCallback callback, boolean initialNotify) {
        getState().ACTIVE6V_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().active6v);
        }
        return new ScopedObject<>(callback, CANCEL_ACTIVE6V_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelActive6vCallback(BooleanCallback)}
     */
    public static final Consumer<BooleanCallback> CANCEL_ACTIVE6V_CALLBACK = RoboRIOSim::cancelActive6vCallback;
    /**
     * Deregisters the given active6v callback
     * @param callback the callback to deregister
     * @see #registerActive6vCallback(BooleanCallback, boolean)
     */
    public static void cancelActive6vCallback(BooleanCallback callback) {
        getState().ACTIVE6V_CALLBACKS.remove(callback);
    }

    /**
     * @return true if 6v rail active, false if inactive
     * @see #setActive6v(boolean)
     */
    public static boolean getActive6v() {
        return getState().active6v;
    }

    /**
     * Set true if 6v rail active, false if inactive
     * @see #getActive6v()
     */
    public static void setActive6v(boolean active6v) {
        setActive6v(active6v, true);
    }

    /**
     * A Consumer which calls the given callback with the current active6v value of this PWMSim
     */
    public static final Consumer<BooleanCallback> CALL_ACTIVE6V_CALLBACK = callback -> callback.callback("", getState().active6v);
    private static void setActive6v(boolean active6v, boolean notifyRobot) {
        if(active6v != getState().active6v) {
            getState().active6v = active6v;
            getState().ACTIVE6V_CALLBACKS.forEach(CALL_ACTIVE6V_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">6v_active", active6v));
        }
    }

    /**
     * Registers a IntegerCallback to be called whenever the faults6v of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current faults6v value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelFaults6vCallback(IntegerCallback)
     */
    public static ScopedObject<IntegerCallback> registerFaults6vCallback(IntegerCallback callback, boolean initialNotify) {
        getState().FAULTS6V_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().faults6v);
        }
        return new ScopedObject<>(callback, CANCEL_FAULTS6V_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelFaults6vCallback(IntegerCallback)}
     */
    public static final Consumer<IntegerCallback> CANCEL_FAULTS6V_CALLBACK = RoboRIOSim::cancelFaults6vCallback;
    /**
     * Deregisters the given faults6v callback
     * @param callback the callback to deregister
     * @see #registerFaults6vCallback(IntegerCallback, boolean)
     */
    public static void cancelFaults6vCallback(IntegerCallback callback) {
        getState().FAULTS6V_CALLBACKS.remove(callback);
    }

    /**
     * @return number of faults on 6v rail
     * @see #setFaults6v(int)
     */
    public static int getFaults6v() {
        return getState().faults6v;
    }

    /**
     * Set number of faults on 6v rail
     * @see #getFaults6v()
     */
    public static void setFaults6v(int faults6v) {
        setFaults6v(faults6v, true);
    }

    /**
     * A Consumer which calls the given callback with the current faults6v value of this PWMSim
     */
    public static final Consumer<IntegerCallback> CALL_FAULTS6V_CALLBACK = callback -> callback.callback("", getState().faults6v);
    private static void setFaults6v(int faults6v, boolean notifyRobot) {
        if(faults6v != getState().faults6v) {
            getState().faults6v = faults6v;
            getState().FAULTS6V_CALLBACKS.forEach(CALL_FAULTS6V_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">6v_faults", faults6v));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the voltage5v of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current voltage5v value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelVoltage5vCallback(DoubleCallback)
     */
    public static ScopedObject<DoubleCallback> registerVoltage5vCallback(DoubleCallback callback, boolean initialNotify) {
        getState().VOLTAGE5V_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().voltage5v);
        }
        return new ScopedObject<>(callback, CANCEL_VOLTAGE5V_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelVoltage5vCallback(DoubleCallback)}
     */
    public static final Consumer<DoubleCallback> CANCEL_VOLTAGE5V_CALLBACK = RoboRIOSim::cancelVoltage5vCallback;
    /**
     * Deregisters the given voltage5v callback
     * @param callback the callback to deregister
     * @see #registerVoltage5vCallback(DoubleCallback, boolean)
     */
    public static void cancelVoltage5vCallback(DoubleCallback callback) {
        getState().VOLTAGE5V_CALLBACKS.remove(callback);
    }

    /**
     * @return 5v rail voltage
     * @see #setVoltage5v(double)
     */
    public static double getVoltage5v() {
        return getState().voltage5v;
    }

    /**
     * Set 5v rail voltage
     * @see #getVoltage5v()
     */
    public static void setVoltage5v(double voltage5v) {
        setVoltage5v(voltage5v, true);
    }

    /**
     * A Consumer which calls the given callback with the current voltage5v value of this PWMSim
     */
    public static final Consumer<DoubleCallback> CALL_VOLTAGE5V_CALLBACK = callback -> callback.callback("", getState().voltage5v);
    private static void setVoltage5v(double voltage5v, boolean notifyRobot) {
        if(voltage5v != getState().voltage5v) {
            getState().voltage5v = voltage5v;
            getState().VOLTAGE5V_CALLBACKS.forEach(CALL_VOLTAGE5V_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">5v_voltage", voltage5v));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the current5v of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current current5v value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelCurrent5vCallback(DoubleCallback)
     */
    public static ScopedObject<DoubleCallback> registerCurrent5vCallback(DoubleCallback callback, boolean initialNotify) {
        getState().CURRENT5V_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().current5v);
        }
        return new ScopedObject<>(callback, CANCEL_CURRENT5V_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelCurrent5vCallback(DoubleCallback)}
     */
    public static final Consumer<DoubleCallback> CANCEL_CURRENT5V_CALLBACK = RoboRIOSim::cancelCurrent5vCallback;
    /**
     * Deregisters the given current5v callback
     * @param callback the callback to deregister
     * @see #registerCurrent5vCallback(DoubleCallback, boolean)
     */
    public static void cancelCurrent5vCallback(DoubleCallback callback) {
        getState().CURRENT5V_CALLBACKS.remove(callback);
    }

    /**
     * @return 5v rail current
     * @see #setCurrent5v(double)
     */
    public static double getCurrent5v() {
        return getState().current5v;
    }

    /**
     * Set 5v rail current
     * @see #getCurrent5v()
     */
    public static void setCurrent5v(double current5v) {
        setCurrent5v(current5v, true);
    }

    /**
     * A Consumer which calls the given callback with the current current5v value of this PWMSim
     */
    public static final Consumer<DoubleCallback> CALL_CURRENT5V_CALLBACK = callback -> callback.callback("", getState().current5v);
    private static void setCurrent5v(double current5v, boolean notifyRobot) {
        if(current5v != getState().current5v) {
            getState().current5v = current5v;
            getState().CURRENT5V_CALLBACKS.forEach(CALL_CURRENT5V_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">5v_current", current5v));
        }
    }

    /**
     * Registers a BooleanCallback to be called whenever the active5v of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current active5v value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelActive5vCallback(BooleanCallback)
     */
    public static ScopedObject<BooleanCallback> registerActive5vCallback(BooleanCallback callback, boolean initialNotify) {
        getState().ACTIVE5V_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().active5v);
        }
        return new ScopedObject<>(callback, CANCEL_ACTIVE5V_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelActive5vCallback(BooleanCallback)}
     */
    public static final Consumer<BooleanCallback> CANCEL_ACTIVE5V_CALLBACK = RoboRIOSim::cancelActive5vCallback;
    /**
     * Deregisters the given active5v callback
     * @param callback the callback to deregister
     * @see #registerActive5vCallback(BooleanCallback, boolean)
     */
    public static void cancelActive5vCallback(BooleanCallback callback) {
        getState().ACTIVE5V_CALLBACKS.remove(callback);
    }

    /**
     * @return true if 5v rail active, false if inactive
     * @see #setActive5v(boolean)
     */
    public static boolean getActive5v() {
        return getState().active5v;
    }

    /**
     * Set true if 5v rail active, false if inactive
     * @see #getActive5v()
     */
    public static void setActive5v(boolean active5v) {
        setActive5v(active5v, true);
    }

    /**
     * A Consumer which calls the given callback with the current active5v value of this PWMSim
     */
    public static final Consumer<BooleanCallback> CALL_ACTIVE5V_CALLBACK = callback -> callback.callback("", getState().active5v);
    private static void setActive5v(boolean active5v, boolean notifyRobot) {
        if(active5v != getState().active5v) {
            getState().active5v = active5v;
            getState().ACTIVE5V_CALLBACKS.forEach(CALL_ACTIVE5V_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">5v_active", active5v));
        }
    }

    /**
     * Registers a IntegerCallback to be called whenever the faults5v of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current faults5v value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelFaults5vCallback(IntegerCallback)
     */
    public static ScopedObject<IntegerCallback> registerFaults5vCallback(IntegerCallback callback, boolean initialNotify) {
        getState().FAULTS5V_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().faults5v);
        }
        return new ScopedObject<>(callback, CANCEL_FAULTS5V_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelFaults5vCallback(IntegerCallback)}
     */
    public static final Consumer<IntegerCallback> CANCEL_FAULTS5V_CALLBACK = RoboRIOSim::cancelFaults5vCallback;
    /**
     * Deregisters the given faults5v callback
     * @param callback the callback to deregister
     * @see #registerFaults5vCallback(IntegerCallback, boolean)
     */
    public static void cancelFaults5vCallback(IntegerCallback callback) {
        getState().FAULTS5V_CALLBACKS.remove(callback);
    }

    /**
     * @return number of faults on 5v rail
     * @see #setFaults5v(int)
     */
    public static int getFaults5v() {
        return getState().faults5v;
    }

    /**
     * Set number of faults on 5v rail
     * @see #getFaults5v()
     */
    public static void setFaults5v(int faults5v) {
        setFaults5v(faults5v, true);
    }

    /**
     * A Consumer which calls the given callback with the current faults5v value of this PWMSim
     */
    public static final Consumer<IntegerCallback> CALL_FAULTS5V_CALLBACK = callback -> callback.callback("", getState().faults5v);
    private static void setFaults5v(int faults5v, boolean notifyRobot) {
        if(faults5v != getState().faults5v) {
            getState().faults5v = faults5v;
            getState().FAULTS5V_CALLBACKS.forEach(CALL_FAULTS5V_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">5v_faults", faults5v));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the voltage3v3 of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current voltage3v3 value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelVoltage3v3Callback(DoubleCallback)
     */
    public static ScopedObject<DoubleCallback> registerVoltage3v3Callback(DoubleCallback callback, boolean initialNotify) {
        getState().VOLTAGE3V3_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().voltage3v3);
        }
        return new ScopedObject<>(callback, CANCEL_VOLTAGE3V3_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelVoltage3v3Callback(DoubleCallback)}
     */
    public static final Consumer<DoubleCallback> CANCEL_VOLTAGE3V3_CALLBACK = RoboRIOSim::cancelVoltage3v3Callback;
    /**
     * Deregisters the given voltage3v3 callback
     * @param callback the callback to deregister
     * @see #registerVoltage3v3Callback(DoubleCallback, boolean)
     */
    public static void cancelVoltage3v3Callback(DoubleCallback callback) {
        getState().VOLTAGE3V3_CALLBACKS.remove(callback);
    }

    /**
     * @return 3.3v rail voltage
     * @see #setVoltage3v3(double)
     */
    public static double getVoltage3v3() {
        return getState().voltage3v3;
    }

    /**
     * Set 3.3v rail voltage
     * @see #getVoltage3v3()
     */
    public static void setVoltage3v3(double voltage3v3) {
        setVoltage3v3(voltage3v3, true);
    }

    /**
     * A Consumer which calls the given callback with the current voltage3v3 value of this PWMSim
     */
    public static final Consumer<DoubleCallback> CALL_VOLTAGE3V3_CALLBACK = callback -> callback.callback("", getState().voltage3v3);
    private static void setVoltage3v3(double voltage3v3, boolean notifyRobot) {
        if(voltage3v3 != getState().voltage3v3) {
            getState().voltage3v3 = voltage3v3;
            getState().VOLTAGE3V3_CALLBACKS.forEach(CALL_VOLTAGE3V3_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">3v3_voltage", voltage3v3));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the current3v3 of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current current3v3 value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelCurrent3v3Callback(DoubleCallback)
     */
    public static ScopedObject<DoubleCallback> registerCurrent3v3Callback(DoubleCallback callback, boolean initialNotify) {
        getState().CURRENT3V3_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().current3v3);
        }
        return new ScopedObject<>(callback, CANCEL_CURRENT3V3_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelCurrent3v3Callback(DoubleCallback)}
     */
    public static final Consumer<DoubleCallback> CANCEL_CURRENT3V3_CALLBACK = RoboRIOSim::cancelCurrent3v3Callback;
    /**
     * Deregisters the given current3v3 callback
     * @param callback the callback to deregister
     * @see #registerCurrent3v3Callback(DoubleCallback, boolean)
     */
    public static void cancelCurrent3v3Callback(DoubleCallback callback) {
        getState().CURRENT3V3_CALLBACKS.remove(callback);
    }

    /**
     * @return 3.3v rail current
     * @see #setCurrent3v3(double)
     */
    public static double getCurrent3v3() {
        return getState().current3v3;
    }

    /**
     * Set 3.3v rail current
     * @see #getCurrent3v3()
     */
    public static void setCurrent3v3(double current3v3) {
        setCurrent3v3(current3v3, true);
    }

    /**
     * A Consumer which calls the given callback with the current current3v3 value of this PWMSim
     */
    public static final Consumer<DoubleCallback> CALL_CURRENT3V3_CALLBACK = callback -> callback.callback("", getState().current3v3);
    private static void setCurrent3v3(double current3v3, boolean notifyRobot) {
        if(current3v3 != getState().current3v3) {
            getState().current3v3 = current3v3;
            getState().CURRENT3V3_CALLBACKS.forEach(CALL_CURRENT3V3_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">3v3_current", current3v3));
        }
    }

    /**
     * Registers a BooleanCallback to be called whenever the active3v3 of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current active3v3 value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelActive3v3Callback(BooleanCallback)
     */
    public static ScopedObject<BooleanCallback> registerActive3v3Callback(BooleanCallback callback, boolean initialNotify) {
        getState().ACTIVE3V3_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().active3v3);
        }
        return new ScopedObject<>(callback, CANCEL_ACTIVE3V3_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelActive3v3Callback(BooleanCallback)}
     */
    public static final Consumer<BooleanCallback> CANCEL_ACTIVE3V3_CALLBACK = RoboRIOSim::cancelActive3v3Callback;
    /**
     * Deregisters the given active3v3 callback
     * @param callback the callback to deregister
     * @see #registerActive3v3Callback(BooleanCallback, boolean)
     */
    public static void cancelActive3v3Callback(BooleanCallback callback) {
        getState().ACTIVE3V3_CALLBACKS.remove(callback);
    }

    /**
     * @return true if 3.3v rail active, false if inactive
     * @see #setActive3v3(boolean)
     */
    public static boolean getActive3v3() {
        return getState().active3v3;
    }

    /**
     * Set true if 3.3v rail active, false if inactive
     * @see #getActive3v3()
     */
    public static void setActive3v3(boolean active3v3) {
        setActive3v3(active3v3, true);
    }

    /**
     * A Consumer which calls the given callback with the current active3v3 value of this PWMSim
     */
    public static final Consumer<BooleanCallback> CALL_ACTIVE3V3_CALLBACK = callback -> callback.callback("", getState().active3v3);
    private static void setActive3v3(boolean active3v3, boolean notifyRobot) {
        if(active3v3 != getState().active3v3) {
            getState().active3v3 = active3v3;
            getState().ACTIVE3V3_CALLBACKS.forEach(CALL_ACTIVE3V3_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">3v3_active", active3v3));
        }
    }

    /**
     * Registers a IntegerCallback to be called whenever the faults3v3 of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current faults3v3 value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelFaults3v3Callback(IntegerCallback)
     */
    public static ScopedObject<IntegerCallback> registerFaults3v3Callback(IntegerCallback callback, boolean initialNotify) {
        getState().FAULTS3V3_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback("", getState().faults3v3);
        }
        return new ScopedObject<>(callback, CANCEL_FAULTS3V3_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelFaults3v3Callback(IntegerCallback)}
     */
    public static final Consumer<IntegerCallback> CANCEL_FAULTS3V3_CALLBACK = RoboRIOSim::cancelFaults3v3Callback;
    /**
     * Deregisters the given faults3v3 callback
     * @param callback the callback to deregister
     * @see #registerFaults3v3Callback(IntegerCallback, boolean)
     */
    public static void cancelFaults3v3Callback(IntegerCallback callback) {
        getState().FAULTS3V3_CALLBACKS.remove(callback);
    }

    /**
     * @return number of faults on 3.3v rail
     * @see #setFaults3v3(int)
     */
    public static int getFaults3v3() {
        return getState().faults3v3;
    }

    /**
     * Set number of faults on 3.3v rail
     * @see #getFaults3v3()
     */
    public static void setFaults3v3(int faults3v3) {
        setFaults3v3(faults3v3, true);
    }

    /**
     * A Consumer which calls the given callback with the current faults3v3 value of this PWMSim
     */
    public static final Consumer<IntegerCallback> CALL_FAULTS3V3_CALLBACK = callback -> callback.callback("", getState().faults3v3);
    private static void setFaults3v3(int faults3v3, boolean notifyRobot) {
        if(faults3v3 != getState().faults3v3) {
            getState().faults3v3 = faults3v3;
            getState().FAULTS3V3_CALLBACKS.forEach(CALL_FAULTS3V3_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.broadcastMessage("", "RoboRIO", new WSValue(">3v3_faults", faults3v3));
        }
    }

    /**
     * An implementation of {@link org.team199.wpiws.interfaces.DeviceMessageProcessor} which processes WPI HALSim messages for RoboRIOSims
     * @param device the device identifier of the device sending the message
     * @param data the data associated with the message
     */
    public static void processMessage(String device, List<WSValue> data) {
        // Process all of the values, but save the "<init" value for last
        // so that the rest of the state has been set when the initialize
        // callback is called.
        WSValue init = null;
        for(WSValue value: data) {
            if (value.getKey().equals("<init"))
                init = value;
            else
                processValue(value);
        }
        if (init != null)
            processValue(init);
    }

    private static final BiConsumer<Boolean, Boolean> SET_FPGABUTTON = RoboRIOSim::setFpgaButton;
    private static final BiConsumer<Double, Boolean> SET_VINVOLTAGE = RoboRIOSim::setVinVoltage;
    private static final BiConsumer<Double, Boolean> SET_VINCURRENT = RoboRIOSim::setVinCurrent;
    private static final BiConsumer<Double, Boolean> SET_VOLTAGE6V = RoboRIOSim::setVoltage6v;
    private static final BiConsumer<Double, Boolean> SET_CURRENT6V = RoboRIOSim::setCurrent6v;
    private static final BiConsumer<Boolean, Boolean> SET_ACTIVE6V = RoboRIOSim::setActive6v;
    private static final BiConsumer<Integer, Boolean> SET_FAULTS6V = RoboRIOSim::setFaults6v;
    private static final BiConsumer<Double, Boolean> SET_VOLTAGE5V = RoboRIOSim::setVoltage5v;
    private static final BiConsumer<Double, Boolean> SET_CURRENT5V = RoboRIOSim::setCurrent5v;
    private static final BiConsumer<Boolean, Boolean> SET_ACTIVE5V = RoboRIOSim::setActive5v;
    private static final BiConsumer<Integer, Boolean> SET_FAULTS5V = RoboRIOSim::setFaults5v;
    private static final BiConsumer<Double, Boolean> SET_VOLTAGE3V3 = RoboRIOSim::setVoltage3v3;
    private static final BiConsumer<Double, Boolean> SET_CURRENT3V3 = RoboRIOSim::setCurrent3v3;
    private static final BiConsumer<Boolean, Boolean> SET_ACTIVE3V3 = RoboRIOSim::setActive3v3;
    private static final BiConsumer<Integer, Boolean> SET_FAULTS3V3 = RoboRIOSim::setFaults3v3;
    private static void processValue(WSValue value) {
        if(value.getKey() instanceof String && value.getValue() != null) {
            switch((String)value.getKey()) {
                
                case ">fpga_button": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Boolean.class, SET_FPGABUTTON);
                    break;
                }
                case ">vin_voltage": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_VINVOLTAGE);
                    break;
                }
                case ">vin_current": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_VINCURRENT);
                    break;
                }
                case ">6v_voltage": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_VOLTAGE6V);
                    break;
                }
                case ">6v_current": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_CURRENT6V);
                    break;
                }
                case ">6v_active": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Boolean.class, SET_ACTIVE6V);
                    break;
                }
                case ">6v_faults": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Integer.class, SET_FAULTS6V);
                    break;
                }
                case ">5v_voltage": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_VOLTAGE5V);
                    break;
                }
                case ">5v_current": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_CURRENT5V);
                    break;
                }
                case ">5v_active": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Boolean.class, SET_ACTIVE5V);
                    break;
                }
                case ">5v_faults": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Integer.class, SET_FAULTS5V);
                    break;
                }
                case ">3v3_voltage": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_VOLTAGE3V3);
                    break;
                }
                case ">3v3_current": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_CURRENT3V3);
                    break;
                }
                case ">3v3_active": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Boolean.class, SET_ACTIVE3V3);
                    break;
                }
                case ">3v3_faults": {
                    StateDevice.filterMessageAndIgnoreRobotState(value.getValue(), Integer.class, SET_FAULTS3V3);
                    break;
                }
                default: {
                    System.err.println("RoboRIOSim ignored unrecognized WSValue: " + value.getKey() + ":" + value.getValue());
                }
            }
        }
    }

    /**
     * Contains all information about the state of a RoboRIOSim
     */
    public static class State {
        public boolean fpgabutton = false;
        public double vinvoltage = 0;
        public double vincurrent = 0;
        public double voltage6v = 0;
        public double current6v = 0;
        public boolean active6v = false;
        public int faults6v = 0;
        public double voltage5v = 0;
        public double current5v = 0;
        public boolean active5v = false;
        public int faults5v = 0;
        public double voltage3v3 = 0;
        public double current3v3 = 0;
        public boolean active3v3 = false;
        public int faults3v3 = 0;
        public final CopyOnWriteArrayList<BooleanCallback> FPGABUTTON_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> VINVOLTAGE_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> VINCURRENT_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> VOLTAGE6V_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> CURRENT6V_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<BooleanCallback> ACTIVE6V_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<IntegerCallback> FAULTS6V_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> VOLTAGE5V_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> CURRENT5V_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<BooleanCallback> ACTIVE5V_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<IntegerCallback> FAULTS5V_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> VOLTAGE3V3_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> CURRENT3V3_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<BooleanCallback> ACTIVE3V3_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<IntegerCallback> FAULTS3V3_CALLBACKS = new CopyOnWriteArrayList<>();
    }

}
