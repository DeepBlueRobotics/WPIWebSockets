// PLEASE DO NOT EDIT THIS FILE!!!
// This file is auto-generated by https://github.com/DeepBlueRobotics/WPIWebSocketsTemplate
// To regenerate please run:
// 'ag -o "WebotsWebSocketsImpl/src/main/org/team199/wpiws/devices" "<path/to/wpilib-ws.yaml>" "https://github.com/DeepBlueRobotics/WPIWebSocketsTemplate.git"'
package org.team199.wpiws.devices;

import java.util.HashMap;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.team199.wpiws.ScopedObject;
import org.team199.wpiws.StateDevice;
import org.team199.wpiws.connection.ConnectionProcessor;
import org.team199.wpiws.connection.WSValue;
import org.team199.wpiws.interfaces.*;

/**
 * Represents a simulated dutycycle
 */
public class DutyCycleSim extends StateDevice<DutyCycleSim.State> {

    private static final HashMap<String, DutyCycleSim.State> STATE_MAP = new HashMap<>();

    /**
     * Creates a new DutyCycleSim
     * @param id the device identifier of this DutyCycleSim 
     */
    public DutyCycleSim(String id) {
        super(id, STATE_MAP);
    }
    
    @Override
    protected State generateState() {
        return new State();
    }
    
    /**
     * Registers a BooleanCallback to be called whenever the connected of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current connected value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelConnectedCallback(BooleanCallback)
     */
    public ScopedObject<BooleanCallback> registerConnectedCallback(BooleanCallback callback, boolean initialNotify) {
        getState().CONNECTED_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().connected);
        }
        return new ScopedObject<>(callback, CANCEL_CONNECTED_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelConnectedCallback(BooleanCallback)}
     */
    public final Consumer<BooleanCallback> CANCEL_CONNECTED_CALLBACK = this::cancelConnectedCallback;
    /**
     * Deregisters the given connected callback
     * @param callback the callback to deregister
     * @see #registerConnectedCallback(BooleanCallback, boolean)
     */
    public void cancelConnectedCallback(BooleanCallback callback) {
        getState().CONNECTED_CALLBACKS.remove(callback);
    }

    /**
     * @return true if the encoder is connected
     * @see #setConnected(boolean)
     */
    public boolean getConnected() {
        return getState().connected;
    }

    /**
     * Set true if the encoder is connected
     * @see #getConnected()
     */
    public void setConnected(boolean connected) {
        setConnected(connected, true);
    }

    /**
     * A Consumer which calls the given callback with the current connected value of this PWMSim
     */
    public final Consumer<BooleanCallback> CALL_CONNECTED_CALLBACK = callback -> callback.callback(id, getState().connected);
    private void setConnected(boolean connected, boolean notifyRobot) {
        if(connected != getState().connected) {
            getState().connected = connected;
            getState().CONNECTED_CALLBACKS.forEach(CALL_CONNECTED_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "DutyCycle", new WSValue(">connected", connected));
        }
    }

    /**
     * Registers a DoubleCallback to be called whenever the position of this device is changed
     * @param callback the callback function to call
     * @param initialNotify if <code>true</code>, calls the callback function with this device's current position value
     * @return a ScopedObject which can be used to close the callback
     * @see #cancelPositionCallback(DoubleCallback)
     */
    public ScopedObject<DoubleCallback> registerPositionCallback(DoubleCallback callback, boolean initialNotify) {
        getState().POSITION_CALLBACKS.addIfAbsent(callback);
        if(initialNotify) {
            callback.callback(id, getState().position);
        }
        return new ScopedObject<>(callback, CANCEL_POSITION_CALLBACK);
    }

    /**
     * A Consumer which calls {@link #cancelPositionCallback(DoubleCallback)}
     */
    public final Consumer<DoubleCallback> CANCEL_POSITION_CALLBACK = this::cancelPositionCallback;
    /**
     * Deregisters the given position callback
     * @param callback the callback to deregister
     * @see #registerPositionCallback(DoubleCallback, boolean)
     */
    public void cancelPositionCallback(DoubleCallback callback) {
        getState().POSITION_CALLBACKS.remove(callback);
    }

    /**
     * @return the position in rotations
     * @see #setPosition(double)
     */
    public double getPosition() {
        return getState().position;
    }

    /**
     * Set the position in rotations
     * @see #getPosition()
     */
    public void setPosition(double position) {
        setPosition(position, true);
    }

    /**
     * A Consumer which calls the given callback with the current position value of this PWMSim
     */
    public final Consumer<DoubleCallback> CALL_POSITION_CALLBACK = callback -> callback.callback(id, getState().position);
    private void setPosition(double position, boolean notifyRobot) {
        if(position != getState().position) {
            getState().position = position;
            getState().POSITION_CALLBACKS.forEach(CALL_POSITION_CALLBACK);
        }
        if(notifyRobot) {
            ConnectionProcessor.brodcastMessage(id, "DutyCycle", new WSValue(">position", position));
        }
    }

    /**
     * An implementation of {@link org.team199.wpiws.interfaces.DeviceMessageProcessor} which processes WPI HALSim messages for DutyCycleSims
     * @param device the device identifier of the device sending the message
     * @param data the data associated with the message
     */
    public static void processMessage(String device, List<WSValue> data) {
        // Process all of the values, but save the "<init" value for last
        // so that the rest of the state has been set when the initialize
        // callback is called.
        WSValue init = null;
        DutyCycleSim simDevice = new DutyCycleSim(device);

        for(WSValue value: data) {
            if (value.getKey().equals("<init"))
                init = value;
            else
                simDevice.processValue(value);
        }
        if (init != null)
            simDevice.processValue(init);
    }

    private final BiConsumer<Boolean, Boolean> SET_CONNECTED = this::setConnected;
    private final BiConsumer<Double, Boolean> SET_POSITION = this::setPosition;
    private void processValue(WSValue value) {
        if(value.getKey() instanceof String && value.getValue() != null) {
            switch((String)value.getKey()) {
                
                case ">connected": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Boolean.class, SET_CONNECTED);
                    break;
                }
                case ">position": {
                    filterMessageAndIgnoreRobotState(value.getValue(), Double.class, SET_POSITION);
                    break;
                }
                default: {
                    System.err.println("DutyCycleSim ignored unrecognized WSValue: " + value.getKey() + ":" + value.getValue());
                }
            }
        }
    }

    /**
     * Contains all information about the state of a DutyCycleSim
     */
    public static class State {
        public boolean connected = false;
        public double position = 0;
        public final CopyOnWriteArrayList<BooleanCallback> CONNECTED_CALLBACKS = new CopyOnWriteArrayList<>();public final CopyOnWriteArrayList<DoubleCallback> POSITION_CALLBACKS = new CopyOnWriteArrayList<>();
    }

}
